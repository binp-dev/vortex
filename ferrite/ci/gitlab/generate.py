from __future__ import annotations
from typing import Dict, List, Optional, Set, Tuple, Union

from pathlib import Path
from dataclasses import dataclass
from graphlib import TopologicalSorter

from ferrite.components.base import Artifact, Component, Task
from ferrite.utils.strings import quote


@dataclass
class Context:
    module: str
    base_dir: Path
    cache: Optional[Cache] = None


@dataclass
class Variables:
    vars: Dict[str, str]

    def text(self) -> List[str]:
        lines = []
        if len(self.vars) > 0:
            lines.extend([
                "variables:",
                *[f"  {k}: \"{v}\"" for k, v in self.vars.items()],
            ])
        return lines


CacheKey = Union[str, List[str]]


@dataclass
class Cache:
    name: str
    patterns: List[Tuple[CacheKey, List[str]]]

    def text(self) -> List[str]:
        lines = []
        if len(self.patterns) > 0:
            lines.append(f"cache: &{self.name}")
            for key, paths in self.patterns:
                if isinstance(key, str):
                    lines.extend([f"  - key: {key}"])
                else:
                    lines.extend([
                        "  - key:",
                        "      files:",
                        *[f"        - {k}" for k in key],
                    ])
                lines.extend([
                    "    paths:",
                    *[f"      - {p}" for p in paths],
                ])
        return lines


class Job:
    Attribute = Union[bool, int, float, str]

    def name(self) -> str:
        raise NotImplementedError()

    def script(self, context: Context) -> List[str]:
        raise NotImplementedError()

    def needs(self) -> List[Job]:
        return []

    def cache(self) -> List[Path]:
        return []

    def artifacts(self) -> List[Path]:
        return []

    def attributes(self) -> Dict[str, Job.Attribute]:
        return {}

    def text(self, context: Context) -> List[str]:
        lines = [
            f"{self.name()}:",
            f"  stage: \"main\"",
            f"  script:",
            f"    - poetry install",
            *[f"    - {sl}" for sl in self.script(context)],
        ]

        if len(self.needs()) > 0:
            lines.extend([
                "  needs:",
                *[f"    - {n}" for n in sorted([dj.name() for dj in self.needs()])],
            ])

        if len(self.artifacts()) > 0:
            paths = sorted([str(art.relative_to(base_dir)) for art in self.artifacts()])
            lines.extend([
                "  artifacts:",
                "    paths:",
                *[f"      - {art}" for art in paths],
            ])
            del paths

        lines.append("  cache:")
        if context.cache is not None:
            lines.append(f"    - *{context.cache.name}")
        cache = self.cache()
        if len(cache) > 0:
            paths = sorted([str(path.relative_to(base_dir)) for path in cache])
            lines.extend([
                "    - paths:",
                *[f"        - {p}" for p in paths],
            ])
            del paths

        for k, v in self.attributes().items():
            if isinstance(v, str):
                sv = quote(v)
            else:
                sv = str(v).lower()
            lines.append(f"  {k}: {sv}")

        return lines


@dataclass
class TaskJob(Job):
    task: Task
    deps: List[Job]

    def name(self) -> str:
        return self.task.name()

    def script(self, context: Context) -> List[str]:
        return [f"poetry run python -u -m {context.module}.manage --no-capture --hide-artifacts {self.name()}"]

    def needs(self) -> List[Job]:
        return self.deps

    def artifacts(self) -> List[Path]:
        return list({art.path for art in self.task.artifacts()})

    def cache(self) -> List[Path]:
        paths: Set[Path] = set()
        for task in TopologicalSorter(self.task.graph()).static_order():
            for art in task.artifacts():
                if art.cached:
                    paths.add(art.path)
        return list(paths)


@dataclass
class ScriptJob(Job):
    _name: str
    _script: List[str]
    allow_failure: bool = False

    def name(self) -> str:
        return self._name

    def script(self, context: Context) -> List[str]:
        return self._script

    def attributes(self) -> Dict[str, Job.Attribute]:
        attrs: Dict[str, Job.Attribute] = {}
        if self.allow_failure:
            attrs["allow_failure"] = True
        return attrs


def make_jobs(components: Component, tasks: List[str]) -> List[Job]:
    jobs: List[Job] = []

    for name in tasks:
        task = components.tasks()[name]
        jobs.append(TaskJob(task, []))

    return jobs


def generate(
    context: Context,
    jobs: List[Job],
    vars: Optional[Variables] = None,
    image_version: str = "latest",
) -> str:
    return "\n".join([
        f"# This file is generated by script '{Path(__file__).relative_to(base_dir)}'",
        "",
        f"image: agerasev/debian-psc:{image_version}",
        "",
        *(vars.text() if vars is not None else []),
        "",
        *(context.cache.text() if context.cache is not None else []),
        "",
        "stages:",
        "  - \"main\"",
        "",
        *["\n".join(job.text(context)) for job in jobs],
        "",
    ])


def default_variables() -> Variables:
    return Variables({
        "GIT_SUBMODULE_STRATEGY": "recursive",
        "POETRY_VIRTUALENVS_IN_PROJECT": "true",
    })


def default_cache(lock_deps: bool = False) -> Cache:
    if not lock_deps:
        poetry = [(["pyproject.toml"], ["poetry.lock", ".venv/"])]
    else:
        poetry = [(["pyproject.toml", "poetry.lock"], [".venv/"])]

    return Cache("global_cache", [
        *poetry,
    ])


def main(
    module: str,
    base_dir: Path,
    components: Component,
    tasks: List[str],
    variables: Variables,
    cache: Cache,
    image_version: str,
) -> None:
    context = Context(module, base_dir, cache)

    print("Collecting jobs ...")
    jobs = make_jobs(components, tasks)
    jobs.append(ScriptJob("mypy", [f"poetry run mypy -p {module}"], allow_failure=True))

    print("Generating script ...")
    text = generate(
        context,
        jobs,
        vars=variables,
        image_version=image_version,
    )

    path = ".gitlab-ci.yml"
    print(f"Writing to '{path}' ...")
    with open(path, "w") as f:
        f.write(text)

    print("Done.")


if __name__ == "__main__":
    from ferrite.components.tree import make_components

    tasks = [
        "all.test",
    ]

    base_dir = Path.cwd()
    target_dir = base_dir / "target"
    components = make_components(base_dir, target_dir)

    main(
        "ferrite",
        base_dir,
        components,
        tasks,
        default_variables(),
        default_cache(),
        image_version="0.3",
    )

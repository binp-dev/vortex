from __future__ import annotations
from typing import Dict, List

import os

from ferrite.components.base import Task
from ferrite.manage.tree import components
from ferrite.manage.paths import BASE_DIR
from ferrite.utils.strings import quote


def text_lines(*lines: str) -> str:
    return "".join([l + "\n" for l in lines])


def base_path(path: str) -> str:
    return os.path.relpath(path, BASE_DIR)


class Cache:

    def is_cached(self, path: str) -> bool:
        raise NotImplementedError()

    def text(self) -> str:
        raise NotImplementedError()


class Job:

    def __init__(self, task: Task, level: int, deps: List[Job]):
        super().__init__()
        self.task = task
        self.level = level
        self.deps = deps

    def name(self) -> str:
        return self.task.name()

    def stage(self) -> str:
        return quote(str(self.level))

    def text(self, cache: Cache) -> str:
        text = text_lines(
            f"{self.name()}:",
            f"  stage: {self.stage()}",
            f"  script:",
            f"    - poetry install",
            f"    - poetry run python -u -m ferrite.manage --no-deps --no-capture {self.name()}",
        )

        if len(self.deps) > 0:
            text += "  needs:\n"
            for dep in self.deps:
                text += f"    - {dep.name()}\n"

        artifacts = []
        for art in self.task.artifacts():
            if not cache.is_cached(art):
                artifacts.append(art)

        if len(artifacts) > 0:
            text += text_lines(
                "  artifacts:",
                "    paths:",
            )
            for art in artifacts:
                text += f"      - {base_path(art)}\n"

        return text


class Graph:

    def __init__(self) -> None:
        self.jobs: Dict[str, Job] = {}

    def add(self, task: Task) -> Job:
        name = task.name()
        if name in self.jobs:
            return self.jobs[name]
        deps = []
        level = 0
        for dep in task.dependencies():
            dj = self.add(dep)
            level = max(level, dj.level + 1)
            deps.append(dj)
        job = Job(task, level, deps)
        self.jobs[name] = job
        return job

    def text(self, cache: Cache) -> str:
        text = ""

        stages = sorted(set([x.stage() for x in self.jobs.values()]))
        text += "\nstages:\n"
        for stg in stages:
            text += f"  - {stg}\n"

        sequence = [j for j in sorted(self.jobs.values(), key=lambda j: j.level)]
        for job in sequence:
            text += "\n"
            text += job.text(cache)

        return text


class PatternCache(Cache):

    def __init__(self, patterns: List[str]):
        super().__init__()
        self.patterns = patterns

    def is_cached(self, path: str) -> bool:
        relpath = base_path(path)
        # FIXME: Use * pattern
        return any([p.replace("*", "") in relpath for p in self.patterns])

    def text(self) -> str:
        text = ""
        if len(self.patterns) > 0:
            text += text_lines(
                "cache:",
                "  paths:",
            )
            for pat in self.patterns:
                text += f"    - {pat}\n"
        return text


if __name__ == "__main__":
    end_tasks = [
        "host_all.test",
        #"imx7_all.build",
        "imx8mn_all.build",
    ]
    cache = PatternCache([
        #"target/epics_base_*",
        #"target/toolchain_*",
    ])

    graph = Graph()
    for etn in end_tasks:
        cn, tn = etn.split(".")
        task = components[cn].tasks()[tn]
        graph.add(task)

    text = f"# This file is generated by script '{base_path(__file__)}'\n\n"
    text += "image: agerasev/debian-psc\n"
    text += cache.text()
    text += graph.text(cache)
    print(text)
